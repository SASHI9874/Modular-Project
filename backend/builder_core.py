import os
import shutil
import subprocess
import sys
from typing import List

# Configuration
REPO_PATH = "modules_repo"
BUILD_DIR = "build_temp"
OUTPUT_DIR = "output_wheels"
PACKAGE_NAME = "my_custom_ai_sdk"  # The name users will import

def clean_dirs():
    """Cleans up previous build artifacts."""
    if os.path.exists(BUILD_DIR):
        shutil.rmtree(BUILD_DIR)
    if os.path.exists(OUTPUT_DIR):
        shutil.rmtree(OUTPUT_DIR)
    os.makedirs(OUTPUT_DIR)

def create_package_structure():
    """Creates the folder structure for the new package."""
    os.makedirs(os.path.join(BUILD_DIR, PACKAGE_NAME))
    # Create an empty README for the package
    with open(os.path.join(BUILD_DIR, "README.md"), "w", encoding="utf-8") as f:
        f.write("# My Custom AI SDK\n\nGenerated by AI Platform.")

def merge_requirements(selected_features: List[str]) -> List[str]:
    """Reads requirements.txt from selected features and merges them."""
    merged_reqs = set()
    
    for feature in selected_features:
        req_path = os.path.join(REPO_PATH, feature, "requirements.txt")
        if os.path.exists(req_path):
            with open(req_path, "r") as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith("#"):
                        merged_reqs.add(line)
    
    return list(merged_reqs)

def copy_sources_and_generate_init(selected_features: List[str]):
    """Copies source code and generates the __init__.py interface."""
    init_lines = []
    
    for feature in selected_features:
        # 1. Read the meta.json to get class name (Simulated here for simplicity)
        # In a real app, you would parse the json. 
        # Here we assume file name matches feature name for simplicity.
        
        src_file = os.path.join(REPO_PATH, feature, "source.py")
        dest_file = os.path.join(BUILD_DIR, PACKAGE_NAME, f"{feature}.py")
        
        # Copy the file
        if os.path.exists(src_file):
            shutil.copy(src_file, dest_file)
            print(f"âœ… Copied {feature}")
            
            # Add to __init__.py
            # Note: We are guessing the class name for this MVP. 
            # Ideally, read this from meta.json!
            if feature == "file_reader": class_name = "FileReader"
            elif feature == "sentiment_analysis": class_name = "SentimentAnalyzer"
            elif feature == "text_extraction": class_name = "TextExtractor"
            elif feature == "embedding": class_name = "EmbeddingGenerator"
            elif feature == "llm_call": class_name = "LLMClient"
            
            init_lines.append(f"from .{feature} import {class_name}")
        else:
            print(f"âŒ Warning: Source not found for {feature}")

    # Write __init__.py
    init_path = os.path.join(BUILD_DIR, PACKAGE_NAME, "__init__.py")
    with open(init_path, "w", encoding="utf-8") as f:
        f.write("\n".join(init_lines))

def create_setup_py(requirements: List[str]):
    """Generates the setup.py file dynamically."""
    setup_content = f"""
from setuptools import setup, find_packages

setup(
    name="{PACKAGE_NAME}",
    version="0.1.0",
    packages=find_packages(),
    install_requires={requirements},
    author="AI Platform User",
    description="A custom generated AI SDK",
)
"""
    with open(os.path.join(BUILD_DIR, "setup.py"), "w", encoding="utf-8") as f:
        f.write(setup_content)

def build_wheel():
    """Runs the python build command."""
    print("ðŸ”¨ Building Wheel...")
    subprocess.run([sys.executable, "-m", "build", "--wheel", "--outdir", f"../{OUTPUT_DIR}"], cwd=BUILD_DIR)


def build_package(selected_features: List[str]) -> str:
    """
    Builds the package and returns the absolute path to the generated .whl file.
    """
    print(f"ðŸš€ Starting Build for: {selected_features}")
    
    clean_dirs()
    create_package_structure()
    
    requirements = merge_requirements(selected_features)
    copy_sources_and_generate_init(selected_features)
    create_setup_py(requirements)
    
    build_wheel()
    
    # Find the generated wheel file
    wheel_dir = os.path.join(os.getcwd(), OUTPUT_DIR)
    files = os.listdir(wheel_dir)
    if not files:
        raise Exception("Build failed: No wheel file generated")
        
    return os.path.join(wheel_dir, files[0])


# builder_core.py (Add these functions)

def generate_main_py(features_in_order: List[str]):
    """
    Generates a main.py that runs the features sequentially.
    Assumes a linear chain: Output of Feature A -> Input of Feature B.
    """
    imports = []
    steps = []
    
    # 1. Generate Imports
    for feature in features_in_order:
        # MAPPING: logic to find class names (same as before)
        if feature == "file_reader": class_name = "FileReader"
        elif feature == "sentiment_analysis": class_name = "SentimentAnalyzer"
        elif feature == "text_extraction": class_name = "TextExtractor"
        elif feature == "embedding": class_name = "EmbeddingGenerator"
        elif feature == "llm_call": class_name = "LLMClient"
        
        imports.append(f"from my_custom_ai_sdk.{feature} import {class_name}")

        # 2. Generate Execution Steps
        # We assume the user instantiates classes with defaults for this MVP
        if feature == "llm_call":
            # Special case: needs API Key
            steps.append(f"    # Step: {feature}")
            steps.append(f"    processor = {class_name}(api_key='YOUR_OPENAI_KEY')")
            steps.append(f"    data = processor.run(data)")
        else:
            steps.append(f"    # Step: {feature}")
            steps.append(f"    processor = {class_name}()")
            steps.append(f"    data = processor.run(data)")

    # 3. Create the file content
    content = f"""
import sys
import os

# Import the generated SDK modules
{chr(10).join(imports)}

def main():
    print("ðŸš€ Starting AI Pipeline...")
    
    # Get initial input from user
    if len(sys.argv) > 1:
        data = sys.argv[1] # Take from command line
    else:
        data = input("Enter input (File Path or Text): ")

    print(f"Input: {{data}}")

    try:
{chr(10).join(steps)}
        
        print("-" * 20)
        print("âœ… Final Output:")
        print(data)
        
    except Exception as e:
        print(f"âŒ Error during execution: {{e}}")

if __name__ == "__main__":
    main()
"""
    with open(os.path.join(BUILD_DIR, "main.py"), "w", encoding="utf-8") as f:
        f.write(content)

def build_standalone_zip(features_in_order: List[str]) -> str:
    """
    Builds the package AND a runnable main.py, then Zips it.
    """
    print(f"ðŸš€ Building ZIP App for chain: {features_in_order}")
    
    clean_dirs()
    create_package_structure()
    
    # 1. Build the library (SDK) inside
    requirements = merge_requirements(features_in_order)
    copy_sources_and_generate_init(features_in_order)
    create_setup_py(requirements)
    
    # 2. Generate the Runner
    generate_main_py(features_in_order)
    
    # 3. Create 'run.sh' for one-click execution
    with open(os.path.join(BUILD_DIR, "run.sh"), "w", encoding="utf-8") as f:
        f.write("#!/bin/bash\npip install .\npython main.py $1")
    
    # 4. ZIP the folder
    zip_filename = "my_ai_app"
    shutil.make_archive(os.path.join(OUTPUT_DIR, zip_filename), 'zip', BUILD_DIR)
    
    return os.path.join(OUTPUT_DIR, f"{zip_filename}.zip")

if __name__ == "__main__":
    # TEST CASE: Let's try to build a package with 3 features
    test_features = ["text_extraction", "llm_call", "sentiment_analysis"]
    build_package(test_features)